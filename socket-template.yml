AWSTemplateFormatVersion: '2010-09-09'
Description: 'WebSocket Chat API with Bedrock Integration - Updated Template'

Parameters:
  Environment:
    Type: String
    Default: dev
    Description: Environment name (dev, staging, prod)
  
  ConnectionTableName:
    Type: String
    Default: websocket-connections
    Description: DynamoDB table name for storing WebSocket connections
    
  BedrockModelId:
    Type: String
    Default: anthropic.claude-3-5-sonnet-20241022-v2:0
    Description: Bedrock model ID to use for chat
    AllowedValues:
      - anthropic.claude-3-5-sonnet-20241022-v2:0
      - anthropic.claude-3-haiku-20240307-v1:0
      - anthropic.claude-sonnet-4-20250514
      - anthropic.claude-opus-4-20241218

Resources:
  # DynamoDB Table for Connection Tracking (unchanged)
  ConnectionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ConnectionTableName}-${Environment}'
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      AttributeDefinitions:
        - AttributeName: connectionId
          AttributeType: S
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: connectionId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: userId-index
          KeySchema:
            - AttributeName: userId
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: websocket-chat

  # IAM Role for Lambda Functions (UPDATED with Bedrock permissions)
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'websocket-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:UpdateItem
                Resource: 
                  - !GetAtt ConnectionTable.Arn
                  - !Sub '${ConnectionTable.Arn}/index/*'
        - PolicyName: ApiGatewayManagement
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:ManageConnections
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/${BedrockModelId}'

  # Lambda Function for Connection Management (unchanged)
  ConnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'websocket-connect-${Environment}'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          TABLE_NAME: !Ref ConnectionTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime, timedelta

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])

          def lambda_handler(event, context):
              connection_id = event['requestContext']['connectionId']
              
              try:
                  # Store connection in DynamoDB
                  ttl = int((datetime.utcnow() + timedelta(hours=2)).timestamp())
                  
                  table.put_item(
                      Item={
                          'connectionId': connection_id,
                          'connectedAt': int(datetime.utcnow().timestamp()),
                          'ttl': ttl
                      }
                  )
                  
                  print(f"Connection {connection_id} stored successfully")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': 'Connected successfully'})
                  }
                  
              except Exception as e:
                  print(f"Error storing connection {connection_id}: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'message': 'Failed to connect'})
                  }

  # Lambda Function for Disconnection Management (unchanged)
  DisconnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'websocket-disconnect-${Environment}'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          TABLE_NAME: !Ref ConnectionTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])

          def lambda_handler(event, context):
              connection_id = event['requestContext']['connectionId']
              
              try:
                  # Remove connection from DynamoDB
                  table.delete_item(
                      Key={'connectionId': connection_id}
                  )
                  
                  print(f"Connection {connection_id} removed successfully")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': 'Disconnected successfully'})
                  }
                  
              except Exception as e:
                  print(f"Error removing connection {connection_id}: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'message': 'Failed to disconnect'})
                  }

  # Lambda Function for Bedrock Chat (UPDATED)
  DefaultFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'websocket-bedrock-chat-${Environment}'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 60
      Environment:
        Variables:
          TABLE_NAME: !Ref ConnectionTable
          ENVIRONMENT: !Ref Environment
          BEDROCK_MODEL_ID: !Ref BedrockModelId
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime

          bedrock_runtime = boto3.client('bedrock-runtime')

          def lambda_handler(event, context):
              connection_id = event['requestContext']['connectionId']
              
              try:
                  # Get the API Gateway management API endpoint
                  domain_name = event['requestContext']['domainName']
                  stage = event['requestContext']['stage']
                  endpoint_url = f"https://{domain_name}/{stage}"
                  
                  apigateway = boto3.client('apigatewaymanagementapi', endpoint_url=endpoint_url)
                  
                  # Parse the incoming message
                  body = json.loads(event.get('body', '{}'))
                  user_message = body.get('message', 'Hello!')
                  
                  print(f"Received message from {connection_id}: {user_message}")
                  
                  # Prepare Bedrock request
                  bedrock_request = {
                      "anthropic_version": "bedrock-2023-05-31",
                      "max_tokens": 1000,
                      "temperature": 0.7,
                      "messages": [
                          {
                              "role": "user",
                              "content": user_message
                          }
                      ]
                  }
                  
                  # Call Bedrock
                  response = bedrock_runtime.invoke_model(
                      modelId=os.environ['BEDROCK_MODEL_ID'],
                      contentType='application/json',
                      accept='application/json',
                      body=json.dumps(bedrock_request)
                  )
                  
                  # Parse Bedrock response
                  response_body = json.loads(response['body'].read())
                  assistant_message = response_body['content'][0]['text']
                  
                  print(f"Bedrock response: {assistant_message[:100]}...")
                  
                  # Prepare response for client
                  response_data = {
                      'type': 'bedrock_response',
                      'message': assistant_message,
                      'model': os.environ['BEDROCK_MODEL_ID'],
                      'timestamp': int(datetime.utcnow().timestamp() * 1000)
                  }
                  
                  # Send response back to client
                  apigateway.post_to_connection(
                      ConnectionId=connection_id,
                      Data=json.dumps(response_data)
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': 'Message processed with Bedrock'})
                  }
                  
              except Exception as e:
                  print(f"Error processing message for connection {connection_id}: {str(e)}")
                  
                  # Send error message to client
                  try:
                      error_response = {
                          'type': 'error',
                          'message': f'Sorry, I encountered an error: {str(e)}',
                          'timestamp': int(datetime.utcnow().timestamp() * 1000)
                      }
                      
                      apigateway.post_to_connection(
                          ConnectionId=connection_id,
                          Data=json.dumps(error_response)
                      )
                  except:
                      pass  # Connection might be closed
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'message': 'Failed to process message'})
                  }

  # WebSocket API Gateway (unchanged)
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub 'websocket-chat-api-${Environment}'
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: '$request.body.action'
      Description: 'WebSocket API for chat application with Bedrock'
      Tags:
        Environment: !Ref Environment
        Application: websocket-chat

  # API Gateway Routes (unchanged)
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$connect'
      Target: !Sub 'integrations/${ConnectIntegration}'

  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$disconnect'
      Target: !Sub 'integrations/${DisconnectIntegration}'

  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$default'
      Target: !Sub 'integrations/${DefaultIntegration}'

  # API Gateway Integrations (unchanged)
  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectFunction.Arn}/invocations'

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DisconnectFunction.Arn}/invocations'

  DefaultIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DefaultFunction.Arn}/invocations'

  # Lambda Permissions (unchanged)
  ConnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ConnectFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  DisconnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DisconnectFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  DefaultPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DefaultFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  # API Gateway Deployment (unchanged)
  ApiDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
      - ConnectRoute
      - DisconnectRoute
      - DefaultRoute
    Properties:
      ApiId: !Ref WebSocketApi

  # API Gateway Stage (unchanged)
  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      DeploymentId: !Ref ApiDeployment
      StageName: !Ref Environment
      Description: !Sub 'Stage for ${Environment}'
      DefaultRouteSettings:
        ThrottlingBurstLimit: 5000
        ThrottlingRateLimit: 2000

Outputs:
  WebSocketURL:
    Description: 'WebSocket connection URL'
    Value: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-WebSocketURL'

  ConnectionTableName:
    Description: 'DynamoDB table name for connections'
    Value: !Ref ConnectionTable
    Export:
      Name: !Sub '${AWS::StackName}-ConnectionTable'

  ApiId:
    Description: 'API Gateway WebSocket API ID'
    Value: !Ref WebSocketApi
    Export:
      Name: !Sub '${AWS::StackName}-ApiId'
      
  BedrockModelId:
    Description: 'Bedrock model being used'
    Value: !Ref BedrockModelId
    Export:
      Name: !Sub '${AWS::StackName}-BedrockModel'